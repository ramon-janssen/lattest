<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="annot"><span class="hs-comment">{- |
    An unsorted collection of utility functions for working with the IO monad.
-}</span></span><span>
</span><span id="line-4"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Lattest.Util.IOUtils</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-5"></span><span class="annot"><span class="hs-comment">-- * Control flow</span></span><span>
</span><span id="line-6"></span><span class="annot"><a href="Lattest.Util.IOUtils.html#ifM_"><span class="hs-identifier">ifM_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-7"></span><span class="annot"><a href="Lattest.Util.IOUtils.html#ifMM_"><span class="hs-identifier">ifMM_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-8"></span><span class="annot"><a href="Lattest.Util.IOUtils.html#ifM"><span class="hs-identifier">ifM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-9"></span><span class="annot"><a href="Lattest.Util.IOUtils.html#ifMM"><span class="hs-identifier">ifMM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-10"></span><span class="annot"><a href="Lattest.Util.IOUtils.html#whileM"><span class="hs-identifier">whileM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-11"></span><span class="annot"><a href="Lattest.Util.IOUtils.html#transformWhile"><span class="hs-identifier">transformWhile</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-12"></span><span class="annot"><a href="Lattest.Util.IOUtils.html#doMaybe"><span class="hs-identifier">doMaybe</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-13"></span><span class="annot"><span class="hs-comment">-- * Encoding state in IO monads</span></span><span>
</span><span id="line-14"></span><span class="annot"><a href="Lattest.Util.IOUtils.html#statefulIO"><span class="hs-identifier">statefulIO</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-15"></span><span class="annot"><a href="Lattest.Util.IOUtils.html#statefulIO%27"><span class="hs-identifier">statefulIO'</span></a></span><span>
</span><span id="line-16"></span><span class="hs-special">)</span><span>
</span><span id="line-17"></span><span class="hs-keyword">where</span><span>
</span><span id="line-18"></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">void</span></span><span class="hs-special">)</span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Conc</span></span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">newTVarIO</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">readTVar</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">writeTVar</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">atomically</span></span><span class="hs-special">)</span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span class="annot"><span class="hs-comment">-- | While-loop for monads. Any state passed between loop iterations should be carried by the monad.</span></span><span>
</span><span id="line-23"></span><span id="local-6989586621679288428"><span class="annot"><a href="Lattest.Util.IOUtils.html#whileM"><span class="hs-identifier hs-type">whileM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679288428"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288428"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288428"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288428"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-24"></span><span id="whileM"><span class="annot"><span class="annottext">whileM :: forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m () -&gt; m ()
</span><a href="Lattest.Util.IOUtils.html#whileM"><span class="hs-identifier hs-var hs-var">whileM</span></a></span></span><span> </span><span id="local-6989586621679288504"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679288504"><span class="hs-identifier hs-var">mb</span></a></span></span><span> </span><span id="local-6989586621679288505"><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679288505"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m () -&gt; m ()
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m ()
</span><a href="Lattest.Util.IOUtils.html#ifMM_"><span class="hs-identifier hs-var">ifMM_</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679288504"><span class="hs-identifier hs-var">mb</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679288505"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">m () -&gt; m () -&gt; m ()
forall a b. m a -&gt; m b -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m () -&gt; m ()
forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m () -&gt; m ()
</span><a href="Lattest.Util.IOUtils.html#whileM"><span class="hs-identifier hs-var">whileM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679288504"><span class="hs-identifier hs-var">mb</span></a></span><span> </span><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679288505"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-25"></span><span>
</span><span id="line-26"></span><span class="annot"><span class="hs-comment">-- | If-statement for monads, with a monadic condition: if the condition holds, execute the given monad and discard the result, otherwise return ().</span></span><span>
</span><span id="line-27"></span><span id="local-6989586621679288430"><span id="local-6989586621679288431"><span class="annot"><a href="Lattest.Util.IOUtils.html#ifMM_"><span class="hs-identifier hs-type">ifMM_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679288430"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288430"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288430"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679288431"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288430"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-28"></span><span id="ifMM_"><span class="annot"><span class="annottext">ifMM_ :: forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m ()
</span><a href="Lattest.Util.IOUtils.html#ifMM_"><span class="hs-identifier hs-var hs-var">ifMM_</span></a></span></span><span> </span><span id="local-6989586621679288511"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679288511"><span class="hs-identifier hs-var">mb</span></a></span></span><span> </span><span id="local-6989586621679288512"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679288512"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-29"></span><span>    </span><span id="local-6989586621679288513"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679288513"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679288511"><span class="hs-identifier hs-var">mb</span></a></span><span>
</span><span id="line-30"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; m a -&gt; m ()
forall (m :: * -&gt; *) a. Applicative m =&gt; Bool -&gt; m a -&gt; m ()
</span><a href="Lattest.Util.IOUtils.html#ifM_"><span class="hs-identifier hs-var">ifM_</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679288513"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679288512"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="annot"><span class="hs-comment">-- | If-statement for monads, with a pure condition: if the condition holds, execute the given monad and discard the result, otherwise return ().</span></span><span>
</span><span id="line-33"></span><span id="local-6989586621679288437"><span id="local-6989586621679288438"><span class="annot"><a href="Lattest.Util.IOUtils.html#ifM_"><span class="hs-identifier hs-type">ifM_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679288437"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288437"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679288438"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288437"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-34"></span><span id="ifM_"><span class="annot"><span class="annottext">ifM_ :: forall (m :: * -&gt; *) a. Applicative m =&gt; Bool -&gt; m a -&gt; m ()
</span><a href="Lattest.Util.IOUtils.html#ifM_"><span class="hs-identifier hs-var hs-var">ifM_</span></a></span></span><span> </span><span id="local-6989586621679288519"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679288519"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679288520"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679288520"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679288519"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">m a -&gt; m ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679288520"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">() -&gt; m ()
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span class="annot"><span class="hs-comment">-- | If-statement for monads, with a monadic condition: if the condition holds, execute the given monad and return the result, otherwise return Nothing.</span></span><span>
</span><span id="line-37"></span><span id="local-6989586621679288445"><span id="local-6989586621679288446"><span class="annot"><a href="Lattest.Util.IOUtils.html#ifMM"><span class="hs-identifier hs-type">ifMM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679288445"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288445"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288445"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679288446"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288445"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679288446"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-38"></span><span id="ifMM"><span class="annot"><span class="annottext">ifMM :: forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m (Maybe a)
</span><a href="Lattest.Util.IOUtils.html#ifMM"><span class="hs-identifier hs-var hs-var">ifMM</span></a></span></span><span> </span><span id="local-6989586621679288525"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679288525"><span class="hs-identifier hs-var">mb</span></a></span></span><span> </span><span id="local-6989586621679288526"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679288526"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-39"></span><span>    </span><span id="local-6989586621679288527"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679288527"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679288525"><span class="hs-identifier hs-var">mb</span></a></span><span>
</span><span id="line-40"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; m a -&gt; m (Maybe a)
forall (m :: * -&gt; *) a. Applicative m =&gt; Bool -&gt; m a -&gt; m (Maybe a)
</span><a href="Lattest.Util.IOUtils.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679288527"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679288526"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-41"></span><span>
</span><span id="line-42"></span><span class="annot"><span class="hs-comment">-- | If-statement for monads, with a pure condition: if the condition holds, execute the given monad and return the result, otherwise return Nothing.</span></span><span>
</span><span id="line-43"></span><span id="local-6989586621679288449"><span id="local-6989586621679288450"><span class="annot"><a href="Lattest.Util.IOUtils.html#ifM"><span class="hs-identifier hs-type">ifM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679288449"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288449"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679288450"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288449"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679288450"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-44"></span><span id="ifM"><span class="annot"><span class="annottext">ifM :: forall (m :: * -&gt; *) a. Applicative m =&gt; Bool -&gt; m a -&gt; m (Maybe a)
</span><a href="Lattest.Util.IOUtils.html#ifM"><span class="hs-identifier hs-var hs-var">ifM</span></a></span></span><span> </span><span id="local-6989586621679288532"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679288532"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679288533"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679288533"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679288532"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe a) -&gt; m a -&gt; m (Maybe a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679288533"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; m (Maybe a)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-45"></span><span>
</span><span id="line-46"></span><span class="annot"><span class="hs-comment">-- | Execute the given Monad, or return () if not present.</span></span><span>
</span><span id="line-47"></span><span id="local-6989586621679288457"><span class="annot"><a href="Lattest.Util.IOUtils.html#doMaybe"><span class="hs-identifier hs-type">doMaybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679288457"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679288457"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288457"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-48"></span><span id="doMaybe"><span class="annot"><span class="annottext">doMaybe :: forall (m :: * -&gt; *). Applicative m =&gt; Maybe (m ()) -&gt; m ()
</span><a href="Lattest.Util.IOUtils.html#doMaybe"><span class="hs-identifier hs-var hs-var">doMaybe</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679288537"><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679288537"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679288537"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-49"></span><span class="annot"><a href="Lattest.Util.IOUtils.html#doMaybe"><span class="hs-identifier hs-var">doMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (m ())
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; m ()
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span>
</span><span id="line-51"></span><span class="annot"><span class="hs-comment">-- | While-loop for monads with explicit state passing.</span></span><span>
</span><span id="line-52"></span><span id="local-6989586621679288459"><span id="local-6989586621679288460"><span class="annot"><a href="Lattest.Util.IOUtils.html#transformWhile"><span class="hs-identifier hs-type">transformWhile</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679288459"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288460"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679288460"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288459"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679288460"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288459"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679288460"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-53"></span><span id="transformWhile"><span class="annot"><span class="annottext">transformWhile :: forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; (a -&gt; m (a, Bool)) -&gt; m a
</span><a href="Lattest.Util.IOUtils.html#transformWhile"><span class="hs-identifier hs-var hs-var">transformWhile</span></a></span></span><span> </span><span id="local-6989586621679288542"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679288542"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span id="local-6989586621679288543"><span class="annot"><span class="annottext">a -&gt; m (a, Bool)
</span><a href="#local-6989586621679288543"><span class="hs-identifier hs-var">transformAndPredicate</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-54"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679288544"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679288544"><span class="hs-identifier hs-var">state'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679288545"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679288545"><span class="hs-identifier hs-var">condition</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m (a, Bool)
</span><a href="#local-6989586621679288543"><span class="hs-identifier hs-var">transformAndPredicate</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679288542"><span class="hs-identifier hs-var">state</span></a></span><span>
</span><span id="line-55"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679288545"><span class="hs-identifier hs-var">condition</span></a></span><span>
</span><span id="line-56"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">a -&gt; (a -&gt; m (a, Bool)) -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; (a -&gt; m (a, Bool)) -&gt; m a
</span><a href="Lattest.Util.IOUtils.html#transformWhile"><span class="hs-identifier hs-var">transformWhile</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679288544"><span class="hs-identifier hs-var">state'</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m (a, Bool)
</span><a href="#local-6989586621679288543"><span class="hs-identifier hs-var">transformAndPredicate</span></a></span><span>
</span><span id="line-57"></span><span>        </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679288544"><span class="hs-identifier hs-var">state'</span></a></span><span>
</span><span id="line-58"></span><span>
</span><span id="line-59"></span><span class="annot"><span class="hs-comment">-- | Produce an IO monad that behaves like the given Mealy machine, with separate transition and output functions.</span></span><span>
</span><span id="line-60"></span><span id="local-6989586621679288464"><span id="local-6989586621679288465"><span id="local-6989586621679288466"><span class="annot"><a href="Lattest.Util.IOUtils.html#statefulIO"><span class="hs-identifier hs-type">statefulIO</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679288464"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288465"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288464"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679288464"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288465"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288466"><span class="hs-identifier hs-type">o</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288464"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679288465"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621679288466"><span class="hs-identifier hs-type">o</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-61"></span><span id="statefulIO"><span class="annot"><span class="annottext">statefulIO :: forall q i o. (q -&gt; i -&gt; q) -&gt; (q -&gt; i -&gt; o) -&gt; q -&gt; IO (i -&gt; IO o)
</span><a href="Lattest.Util.IOUtils.html#statefulIO"><span class="hs-identifier hs-var hs-var">statefulIO</span></a></span></span><span> </span><span id="local-6989586621679288546"><span class="annot"><span class="annottext">q -&gt; i -&gt; q
</span><a href="#local-6989586621679288546"><span class="hs-identifier hs-var">transitionFunction</span></a></span></span><span> </span><span id="local-6989586621679288547"><span class="annot"><span class="annottext">q -&gt; i -&gt; o
</span><a href="#local-6989586621679288547"><span class="hs-identifier hs-var">outputFunction</span></a></span></span><span> </span><span id="local-6989586621679288548"><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288548"><span class="hs-identifier hs-var">initialState</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(q -&gt; i -&gt; (q, o)) -&gt; q -&gt; IO (i -&gt; IO o)
forall q i o. (q -&gt; i -&gt; (q, o)) -&gt; q -&gt; IO (i -&gt; IO o)
</span><a href="Lattest.Util.IOUtils.html#statefulIO%27"><span class="hs-identifier hs-var">statefulIO'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679288549"><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288549"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621679288550"><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679288550"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">q -&gt; i -&gt; q
</span><a href="#local-6989586621679288546"><span class="hs-identifier hs-var">transitionFunction</span></a></span><span> </span><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288549"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679288550"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">q -&gt; i -&gt; o
</span><a href="#local-6989586621679288547"><span class="hs-identifier hs-var">outputFunction</span></a></span><span> </span><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288549"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679288550"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288548"><span class="hs-identifier hs-var">initialState</span></a></span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span class="annot"><span class="hs-comment">-- | Produce an IO monad that behaves like the given Mealy machine, with a combined transition/output function.</span></span><span>
</span><span id="line-64"></span><span id="local-6989586621679288470"><span id="local-6989586621679288471"><span id="local-6989586621679288472"><span class="annot"><a href="Lattest.Util.IOUtils.html#statefulIO%27"><span class="hs-identifier hs-type">statefulIO'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679288470"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288471"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679288470"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679288472"><span class="hs-identifier hs-type">o</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679288470"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679288471"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="annot"><a href="#local-6989586621679288472"><span class="hs-identifier hs-type">o</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-65"></span><span id="statefulIO%27"><span class="annot"><span class="annottext">statefulIO' :: forall q i o. (q -&gt; i -&gt; (q, o)) -&gt; q -&gt; IO (i -&gt; IO o)
</span><a href="Lattest.Util.IOUtils.html#statefulIO%27"><span class="hs-identifier hs-var hs-var">statefulIO'</span></a></span></span><span> </span><span id="local-6989586621679288558"><span class="annot"><span class="annottext">q -&gt; i -&gt; (q, o)
</span><a href="#local-6989586621679288558"><span class="hs-identifier hs-var">transitionFunction</span></a></span></span><span> </span><span id="local-6989586621679288559"><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288559"><span class="hs-identifier hs-var">initialState</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-66"></span><span>    </span><span id="local-6989586621679288560"><span class="annot"><span class="annottext">TVar q
</span><a href="#local-6989586621679288560"><span class="hs-identifier hs-var">stateRef</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">q -&gt; IO (TVar q)
forall a. a -&gt; IO (TVar a)
</span><span class="hs-identifier hs-var">newTVarIO</span></span><span> </span><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288559"><span class="hs-identifier hs-var">initialState</span></a></span><span>
</span><span id="line-67"></span><span>    </span><span class="annot"><span class="annottext">(i -&gt; IO o) -&gt; IO (i -&gt; IO o)
forall a. a -&gt; IO a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">((i -&gt; IO o) -&gt; IO (i -&gt; IO o)) -&gt; (i -&gt; IO o) -&gt; IO (i -&gt; IO o)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679288561"><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679288561"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">STM o -&gt; IO o
forall a. STM a -&gt; IO a
</span><span class="hs-identifier hs-var">atomically</span></span><span> </span><span class="annot"><span class="annottext">(STM o -&gt; IO o) -&gt; STM o -&gt; IO o
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-68"></span><span>        </span><span id="local-6989586621679288562"><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288562"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">TVar q -&gt; STM q
forall a. TVar a -&gt; STM a
</span><span class="hs-identifier hs-var">readTVar</span></span><span> </span><span class="annot"><span class="annottext">TVar q
</span><a href="#local-6989586621679288560"><span class="hs-identifier hs-var">stateRef</span></a></span><span>
</span><span id="line-69"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679288563"><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288563"><span class="hs-identifier hs-var">state'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679288564"><span class="annot"><span class="annottext">o
</span><a href="#local-6989586621679288564"><span class="hs-identifier hs-var">output</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">q -&gt; i -&gt; (q, o)
</span><a href="#local-6989586621679288558"><span class="hs-identifier hs-var">transitionFunction</span></a></span><span> </span><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288562"><span class="hs-identifier hs-var">state</span></a></span><span> </span><span class="annot"><span class="annottext">i
</span><a href="#local-6989586621679288561"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-70"></span><span>        </span><span class="annot"><span class="annottext">TVar q -&gt; q -&gt; STM ()
forall a. TVar a -&gt; a -&gt; STM ()
</span><span class="hs-identifier hs-var">writeTVar</span></span><span> </span><span class="annot"><span class="annottext">TVar q
</span><a href="#local-6989586621679288560"><span class="hs-identifier hs-var">stateRef</span></a></span><span> </span><span class="annot"><span class="annottext">q
</span><a href="#local-6989586621679288563"><span class="hs-identifier hs-var">state'</span></a></span><span>
</span><span id="line-71"></span><span>        </span><span class="annot"><span class="annottext">o -&gt; STM o
forall a. a -&gt; STM a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">o
</span><a href="#local-6989586621679288564"><span class="hs-identifier hs-var">output</span></a></span><span>
</span><span id="line-72"></span></pre></body></html>